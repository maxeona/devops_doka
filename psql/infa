1.Работа в терминале через клиент psql(некоторые команды):
\t -on/off (rows) in select 
\a - on/off выравнивание
\! {command_os} -выполнение команд shell (?)
\i {name_file} - выполнение скрипта or psql -f {name_file} or psql < {file_name}
\d {pg_shadow, pg_tables, etc} - show inform about object db

2.Конфигурация
show config_file; - расположение конфигурационного файла
При изменении каких-либо параметров, файл необходимо перечитать: 
    а) pg_ctl reload
    б) select pg_reload_conf();
!изменения некоторых параметров требует перезапуска сервера
ALTER SYSTEM - редактирование конфиг файла psql  удаленно
но без релоад не применит изменения
CREATE SCHEMA имя_схемы AUTHORIZATION имя_пользователя; - создание схемы, чьим владельцем является другой пользователь(не тот, который выполняет команду )
******************************************************************************************
Привилегии

***Таблицы***
SELECT (можн на уровне столбцов)
INSERT (можн на уровне столбцов)
UPDATE (можн на уровне столбцов)
REFERENCES - external key (можн на уровне столбцов)
DELETE
TRUNCATE - опустошение таблицы
TRIGGER - create trigger

***Представления***
SELECT - чттение данных
TRIGGER - создание триггеров

***Табличные пространства***
CREATE - право создавать в этом пространстве объекты

***База данных***
CONNECT - connect to db by user
CREATE - можно ли создавать схемы внутри бд
TEMPORARY - создание временных объектов

***Схемы***
CREATE - право создаваь объекты внутри схемы 
USAGE - использовать существующие объекты

***Последовательности***
SELECT currval
UPDATE nextval setval
USAGE currval nextval 

###############################################################
                        Архитектура psql
###############################################################
!По умолчанию, psql работает в режиме автофиксации 
\echo :AUTOCOMMIT
Это приводит к тому, что любая команда, выданная без явного указания транзакции BTGIN; сразу же фиксируются 
\set AUTOCOMMIT off/on - выкл режим
*В разных яп, разные драйверы по разному исп. данный режим

BEGIN;
....
SAVEPOINT sp; -точка сохранения 
....
ROLLBACK TO sp; (откат изменений до точки фиксации)
...
COMMIT;

Этапы каждого запроса:

разбор
переписывание
--------------------
привязка
планирование
выполнение

****************************************************************
2.VACUUM
Предназначен для очистки таблиц. Удаляет неактивные строки в таблицах и индексах, и помечает пространство, как доступное для повторного использования в будущем 
1)Для восстановления или повторного использования дискового пространства, занятого обновленными или удаленными строками.
2)Для обновления статистики данных используется планировщик запросов PostgreSQL .
3)Чтобы обновить карту видимости, которая ускоряет сканирование только индексов .
4)Для защиты от потери очень старых данных из-за циклического переноса идентификатора транзакции или мультитранзакционного идентификатора .

Два варика применения VACUUM:
стандартный VACUUM и VACUUM FULL
стандартный не будет блокировать некоторые операции рабочей базы, такие как (SELECT, INSERT, UPDATEи DELETE), но вы не сможете изменить определение таблицы с помощью таких команд, как ALTER TABLEво время ее очистки.
VACUUM FULL блокирует таблицы, над которой работает, поэтмоу параллельно нельзя другим юзать таблицу.

Почитать про индексы 

3.Резервное копирование и восстановление
 Существует три принципиально разных подхода к резервному копированию данных PostgreSQL :
    а)дамп SQL - создание файла с командами sql, которые при отправке обратно на сервер воссоздают базу данных в том же состоянии, в каком она была во время создания дампа. 
pg_dump {dbname} > {dbfile}
pg_dump — это обычное клиентское приложение PostgreSQL (хотя и очень умное). Это означает, что вы можете выполнить эту процедуру резервного копирования с любого удаленного хоста, имеющего доступ к базе данных. 
pg_dump не блокирует другие операции с базой данных во время работы. (Исключениями являются те операции, которые должны работать с монопольной блокировкой, например большинство форм ALTER TABLE.)
Важно!  База данных dbnameне будет создана этой командой, поэтому вы должны создать ее самостоятельно
Важно! Перед восстановлением дампа SQL должны уже существовать все пользователи (но там вроде ключ --no-acl ) добавить
--set ON_ERROR_STOP=on
 что бы восстановление не продолжалось при error
pg_dump dbname| gzip > filename.gz  - сжать бэкап(подходит для больших баз)
gunzip -c filename.gz | psqldbname - вытащить
    б)Резервное копирование на уровне файловой системы
Пример:
tar -cf backup.tar /usr/local/pgsql/data
    в)Непрерывное архивирование
psql постоянно ведет журнал упреждающей записи (WAL) в pg_wal . там записываются все изменения, внесенные в файлы данных бд.

4. Мониторинг активности бд
Стандартные инструменты Unix:
вывод ps(может быть в статусе idle(ожидание команды клиента), idle in transaction(ожидание клиента внутри BEGINблока))

Табличные пространства
В отличие от логического распределения объектов по базам данных и схемам, табличные пространства определяют физическое расположение данных. Фактически табличное пространство — это каталог файловой системы
При инициализации кластера создаются два табличных пространства:
* pg_default располагается в каталоге PGDATA/base и используется как табличное пространство по умолчанию, если явно не выбрать для этой цели
другое пространство;
* pg_global располагается в каталоге PGDATA/global и хранит общие для всего
кластера объекты системного каталога

Чтобы клиент и сервер понимали друг друга, они должны использовать один
и тот же протокол взаимодействия3
. Обычно для реализации протокола используют штатную библиотеку libpq, хотя встречаются и независимые реализации.


https://tableplus.com/blog/2018/04/postgresql-how-to-grant-access-to-users.html
